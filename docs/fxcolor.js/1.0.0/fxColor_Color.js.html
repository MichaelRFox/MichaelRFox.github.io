<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>fxColor/Color.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/MichaelRFox/fxColor" target="_blank" class="menu-item" id="source_link" >Source Code</a></h2><h3>Classes</h3><ul><li><a href="Color.html">Color</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Color.html#colorSpace">colorSpace</a></li><li data-type='method' style='display: none;'><a href="Color.html#observer">observer</a></li><li data-type='method' style='display: none;'><a href="Color.html#alpha">alpha</a></li><li data-type='method' style='display: none;'><a href="Color.html#CMYK">CMYK</a></li><li data-type='method' style='display: none;'><a href="Color.html#CSScolor">CSScolor</a></li><li data-type='method' style='display: none;'><a href="Color.html#HEX">HEX</a></li><li data-type='method' style='display: none;'><a href="Color.html#HSL">HSL</a></li><li data-type='method' style='display: none;'><a href="Color.html#HSV">HSV</a></li><li data-type='method' style='display: none;'><a href="Color.html#HWB">HWB</a></li><li data-type='method' style='display: none;'><a href="Color.html#LAB">LAB</a></li><li data-type='method' style='display: none;'><a href="Color.html#LCHab">LCHab</a></li><li data-type='method' style='display: none;'><a href="Color.html#LUV">LUV</a></li><li data-type='method' style='display: none;'><a href="Color.html#LCHuv">LCHuv</a></li><li data-type='method' style='display: none;'><a href="Color.html#RGB">RGB</a></li><li data-type='method' style='display: none;'><a href="Color.html#RGBint">RGBint</a></li><li data-type='method' style='display: none;'><a href="Color.html#w3cColor">w3cColor</a></li><li data-type='method' style='display: none;'><a href="Color.html#XYZ">XYZ</a></li><li data-type='method' style='display: none;'><a href="Color.html#darken">darken</a></li><li data-type='method' style='display: none;'><a href="Color.html#lighten">lighten</a></li><li data-type='method' style='display: none;'><a href="Color.html#saturate">saturate</a></li><li data-type='method' style='display: none;'><a href="Color.html#desaturate">desaturate</a></li><li data-type='method' style='display: none;'><a href="Color.html#contrastText">contrastText</a></li></ul></li><li><a href="colorRampD.html">colorRampD</a></li></ul><h3>Modules</h3><ul><li><a href="module-alpha.html">alpha</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-alpha.html#.alpha">alpha</a></li></ul></li><li><a href="module-cmyk.html">cmyk</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-cmyk.html#.CMYK">CMYK</a></li></ul></li><li><a href="module-contrastText.html">contrastText</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-contrastText.html#~contrastTextOLD">contrastTextOLD</a></li><li data-type='method' style='display: none;'><a href="module-contrastText.html#~contrastText">contrastText</a></li></ul></li><li><a href="module-rgbColorSpace.html">rgbColorSpace</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-rgbColorSpace.html#~colorSpace">colorSpace</a></li><li data-type='method' style='display: none;'><a href="module-rgbColorSpace.html#~observer">observer</a></li></ul></li><li><a href="module-validate.html">validate</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-validate.html#~validateColorSpace">validateColorSpace</a></li><li data-type='method' style='display: none;'><a href="module-validate.html#~arrayEqual">arrayEqual</a></li><li data-type='method' style='display: none;'><a href="module-validate.html#~validate">validate</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#HSLtoRGB">HSLtoRGB</a></li><li><a href="global.html#HWBtoRGB">HWBtoRGB</a></li><li><a href="global.html#RGBtoHWB">RGBtoHWB</a></li><li><a href="global.html#RGBtoLuminance">RGBtoLuminance</a></li><li><a href="global.html#parseColor">parseColor</a></li><li><a href="global.html#parsePercent">parsePercent</a></li><li><a href="global.html#CSScolor">CSScolor</a></li><li><a href="global.html#darken">darken</a></li><li><a href="global.html#desaturate">desaturate</a></li><li><a href="global.html#HEX">HEX</a></li><li><a href="global.html#HSL">HSL</a></li><li><a href="global.html#HSV">HSV</a></li><li><a href="global.html#HWB">HWB</a></li><li><a href="global.html#LAB">LAB</a></li><li><a href="global.html#LCHab">LCHab</a></li><li><a href="global.html#LCHuv">LCHuv</a></li><li><a href="global.html#lighten">lighten</a></li><li><a href="global.html#RGB">RGB</a></li><li><a href="global.html#RGBint">RGBint</a></li><li><a href="global.html#saturate">saturate</a></li><li><a href="global.html#XYZ">XYZ</a></li><li><a href="global.html#clampColor">clampColor</a></li><li><a href="global.html#illuminant">illuminant</a></li><li><a href="global.html#returnColor">returnColor</a></li><li><a href="global.html#trim">trim</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">fxColor/Color.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {validateRange, validate, validateColorSpace} from '../utility/validate.js';
import {returnColor} from '../utility/returnColor.js';
import {CMYKtoRGB} from '../conversions/cmykConversions.js';
import {RGBtoXYZ, RGBtoCMYK, RGBtoLuminance, RGBtoHSL, RGBtoHEX, RGBtoHWB, INTtoRGB, RGBtoINT, RGBtoW3C, W3CtoRGB, RGBtoHSV} from '../conversions/rgbConversions.js';
import {XYZtoRGB, XYZtoLUV, XYZtoLAB} from '../conversions/xyzConversions.js';
import {LABtoXYZ, LABtoLCHab} from '../conversions/labConversions.js';
import {HSLtoRGB} from '../conversions/hslConversions.js';
import {HSVtoRGB} from '../conversions/hsvConversions.js';
import {HWBtoRGB} from '../conversions/hwbConversions.js';
import {LCHabToLAB} from '../conversions/lchabConversions.js';
import {LCHuvToLUV} from '../conversions/lchuvConversions.js';
import {LUVtoXYZ, LUVtoLCHuv} from '../conversions/luvConversions.js';
import {parseCmyk, parseColor, parsePercent, parseHsl, parseHsv, parseHwb, parseLab, parseLch, parseRgb, parseHex, parseLuv} from '../css/cssParsers.js';
import {format} from '../css/cssFormat.js';
import {w3cColors} from '../data/w3cColors.js';
import {rgbColorSpaces} from '../data/rgbColorSpaces.js';
import {illuminants} from '../data/illuminants.js';

/**
 * The Color class
 */
export class Color {

    #colorSpace;
    #observer;
    #xyz = {x: 0, y: 0, z: 0};
    #alpha = 1;
    #outOfGamut = false;
    
    /**
     * Instantiates a new Color class object.
     * @param {string} colorSpace The rgb color space to use (optional). One of
     * ['Adobe RGB' | 'Apple RGB' | 'Best RGB' | 'Beta RGB' | 'Bruce RGB' |
     * 'CIE RGB' | 'ColorMatch RGB' | Don RGB 4' | 'ECI RGB' | 'Ekta Space PS5'
     * | 'NTSC RGB' | 'PAL/SECAM RGB' | 'ProPhoto RGB' | 'SMPTE-C RGB' | 'sRGB'
     * | 'Wide Gamut RGB']. **Default**: 'Adobe RGB'.
     * @param {number} observer The observer (optional). One of [2 | 10]. **Default**: 2.
     */
    constructor (colorSpace = 'Adobe RGB', observer = 2) {

        this.colorSpace(colorSpace);
        this.observer(observer);
    }

    /**
     * Sets or returns the [Color class object's]{@link Color} color space.
     * @param {string} colorSpace The color space to set.
     * @returns {(Color | Object)} If the colorSpace argument is passed, returns the
     * [Color class Object]{@link Color}. Otherwise the current colorSpace is returned.
     */
    colorSpace (colorSpace) {

        if (colorSpace == undefined) return this.#colorSpace;

        if (validateColorSpace(colorSpace)) {
            this.#colorSpace = rgbColorSpaces.filter(d => d.name == colorSpace)[0];
        };

        return this
    }

    /**
     * Sets or returns the current Color class object's observer.
     * @param {number} observer Which observer to set. One of [2 | 10].
     * @returns {(Color | number)} If the observer argument is passed, returns the
     * [Color class Object]{@link Color}. Otherwise, the current observer.
     */
    observer (observer) {

        if (observer == undefined) return this.#observer;
        if (observer.indexOf[2, 10] == -1) {
            console.error(`The observer, ${observer} is invalid. The observer must be one of [2 | 10].`);
        } else  {
            this.#observer = observer;
        };
        return this
    }

    /**
     * Sets the opacity of the Color class object or alternatively returns its current value.
     * @param {number} opacity The opacity for 0 (transparent) to 1 (opaque).
     * @returns {(Color | Number)} If the opacity argument is omitted, the current Color
     * class object's opacity, otherwise the [Color class object]{@link Color}.
     */
    alpha (opacity) {

        if (opacity == undefined) return this.#alpha;
        if (validateRange(opacity)) {
             this.#alpha = opacity;
        };
        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a cmyk value, or returns the cmyk value of the current Color class object.
     * @param {(Array | Object | String)} cmyk If cmyk is an array, it should contain four elements
     * representing the cyan, magenta, yellow, and black components (e.g., [0.4, 0.5, 1, 0.9]).
     * If cmyk is an object it should contain key/value pairs for the four color components
     * (e.g., {c: 0.4, m: 1, y: 0.9, k: 1]}). If cmyk is a string, it should be a W3C CSS formatted
     * string (e.g., 'cmyk(0.5, 0.5, 0.5, 0.5)'. Additionally, a fifth component component for the
     * alpha channel may be added. If cmyk is an object the alpha component key should be *alpha*.
     * @returns {(Color | String)} If the cmyk argument is not passed, A CSS cmyk color specification
     * of the current [Color class object's]{@link Color} color value (e.g., cmyk(0.5, 0.4, 1, 0.9)
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    CMYK (cmyk) { 

        let rgb;

        if (cmyk == undefined) {
            rgb = XYZtoRGB(this.#xyz, this.#colorSpace);
            return format('cmyk', RGBtoCMYK(rgb), this.#alpha);
        };
        
        const ranges = [{min:0,max:1},{min:0,max:1},{min:0,max:1},{min:0,max:1},{min:0,max:1}];
        const keys = ['c', 'm', 'y', 'k'];

        let {components, alpha} = validate(cmyk, keys, ranges, parseCmyk);
        
        if (components != undefined) {
            rgb = CMYKtoRGB (components);
            this.#xyz = RGBtoXYZ (rgb, this.#colorSpace);
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;
    }

    /**
     * Sets or retrieves the [Color class object's]{@link Color} color.
     * @param {(String | undefined)} color Any valid CSS color specification.
     * @param {String} format The desired format to return the
     * [Color class object's]{@link Color} color. One of
     * ['cmyk' | 'hex' | 'hsl' | 'hsv' | 'hwb' | 'lab' | 'lch' | rgb' | 'int'].
     * **Default**: 'rgb'.
     * @returns {(Color | String)} If the color argument is not provided, the
     * current Color class object's{@link Color} color is returned as a CSS
     * RGB color specification. Otherwise, the [Color class object]{@link Color}
     * is returned.
     */
    CSScolor (color, format = 'rgb') {
        
        if (color == undefined) {
            return returnColor(this.#xyz, this.#colorSpace, this.#observer, this.#alpha, format); 
        };

        const parsedColor = parseColor(color);
        
        if (parsedColor != undefined) {
            const keys = Object.keys(parsedColor);
            const signature = keys.join('');

            switch (signature) {
                case 'cmyk': this.#xyz = RGBtoXYZ(CMYKtoRGB(parsedColor), this.#colorSpace);
                case 'hsl': this.#xyz = RGBtoXYZ(HSLtoRGB(parsedColor), this.#colorSpace);
                case 'hsv': this.#xyz = RGBtoXYZ(HSVtoRGB(parsedColor), this.#colorSpace);
                case 'hwb': this.#xyz = RGBtoXYZ(HWBtoRGB(parsedColor), this.#colorSpace);
                case 'lab': this.#xyz = LABtoXYZ(parsedColor, this.#colorSpace, this.#observer);
                case 'lch': this.#xyz = LABtoXYZ(LCHabToLAB(parsedColor), this.#colorSpace, this.#observer);
                case 'rgb': this.#xyz = RGBtoXYZ (rgb, this.#colorSpace);
            };
            
            this.#alpha = parsedColor.alpha == undefined ? this.#alpha : parsedColor.alpha;
        };

        return this
    }    

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a RGB hex value, or returns the RGB hex value of the current color.
     * @param {(Array | Object | String)} hex If hex is an array, it should contain three elements
     * representing the red, green, and blue components (e.g., [0xFF, 0x80, 0x0]).
     * If hex is an object it should contain key/value pairs for the three color components
     * (e.g., {r: 0xFF, g: 0x80, b: 0x0]}). If hex is a string, it should be a W3C CSS formatted
     * string (e.g., '#FF8000'. Additionally, a fifth component component for the
     * alpha channel may be added. If hex is an object the alpha component key should be *alpha*.
     * @returns {(Color | String)} If the hex argument is not passed, A CSS RGB hex color specification
     * of the current [Color class object's]{@link Color} color value (e.g., '#FF8000')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    HEX (hex) {

        if (hex == undefined) return format('hex', RGBtoHEX(XYZtoRGB(this.#xyz, this.#colorSpace)), this.#alpha);

        const ranges = [{min:0x0,max:0xFF},{min:0x0,max:0xFF},{min:0x0,max:0xFF},{min:0x0,max:0xFF},{min:0x0,max:0xFF}];
        const keys = ['r', 'g', 'b'];

        let {components, alpha} = validate(hex, keys, ranges, parseHex);

        if (components != undefined) {
            this.#xyz = RGBtoXYZ(HEXtoRGB(components), this.#colorSpace)
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * an hsl value, or returns the hls value of the current color.
     * @param {(Array | Object | String)} hsl The hsl argument should be either an
     * array, object, or string representing the hue, saturation, and luminance
     * components of the desired color. Valid values for these components are:
     * 
     * - h: 0 to 360 (degrees)
     * - s: 0 to 100%
     * - l: 0 to 100%
     * 
     * If hsl is an array, it should contain three elements
     * representing the hue, saturation, and luminance components (e.g., [250, 0.5, 1]).
     * If hsl is an object it should contain key/value pairs for the three color components
     * (e.g., {h: 250, s: 0.5, l: 1]}). If hsl is a string, it should be a W3C CSS formatted
     * string (e.g., 'hsl(250, 0.5, 1)'. Additionally, a fourth component component for the
     * alpha channel may be added. If hsl is an object the alpha component key should be *alpha*.
     * @returns {(Color | String)} If the hsl argument is not passed, A CSS hsl color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'hsl(250, 0.5, 1)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    HSL (hsl) {
        
        let rgb;

        if (arguments.length == 0) {
            rgb = XYZtoRGB(this.#xyz, this.#colorSpace);
            return format('hsl', RGBtoHSL(rgb), this.#alpha);
        };

        const ranges = [{min:0,max:360},{min:0,max:1},{min:0,max:1},{min:0,max:1}];
        const keys = ['h', 's', 'l'];

        const {components, alpha} = validate(hsl, keys, ranges, parseHsl);

        if (components != undefined) {
            rgb = HSLtoRGB (components);
            this.#xyz = RGBtoXYZ (rgb, this.#colorSpace);
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * an hsv value, or returns the hsv value of the current color.
     * @param {(Array | Object | String)} hsv The hsv argument should be either an
     * array, object, or string representing the hue, saturation, and value
     * components of the desired color. Valid values for these components are:
     * 
     * - h: 0 to 360 (degrees)
     * - s: 0 to 100%
     * - v: 0 to 100%
     * 
     * If hsv is an array, it should contain three elements
     * representing the hue, saturation, and value components (e.g., [250, 0.5, 1]).
     * If hsv is an object it should contain key/value pairs for the three color components
     * (e.g., {h: 250, s: 0.5, v: 1]}). If hsv is a string, it should be a W3C CSS formatted
     * string (e.g., 'hsv(250, 0.5, 1)'. Note that hsv is not currently a W3C-accepted color
     * specification, but is provided for flexibility. Additionally, a fourth component component for the
     * alpha channel may be added. If hsv is an object the alpha component key should be *alpha*.
     * @returns {(Color | String)} If the hsv argument is not passed, A CSS hsv color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'hsv(250, 0.5, 1)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    HSV (hsv) {
        
        let rgb;

        if (hsv == undefined) {
            rgb = XYZtoRGB(this.#xyz, this.#colorSpace);
            return format('hsv', RGBtoHSV(rgb), this.#alpha);
        };

        const ranges = [{min:0,max:360},{min:0,max:1},{min:0,max:1},{min:0,max:1}];
        const keys = ['h', 's', 'v'];

        const {components, alpha} = validate(hsv, keys, ranges, parseHsv);

        if (components != undefined) {
            rgb = HSVtoRGB (components);
            this.#xyz = RGBtoXYZ (rgb, this.#colorSpace);
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;            
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * an hwb value, or returns the hlv value of the current color.
     * @param {(Array | Object | String)} hwb The hwb argument should be either an
     * array, object, or string representing the hue, whiteness, and blackness
     * components of the desired color. Valid values for these components are:
     * 
     * - h: 0 to 360 (degrees)
     * - w: 0 to 100%
     * - b: 0 to 100%
     * 
     * If hwb is an array, it should contain three elements
     * representing the hue, saturation, and value components (e.g., [250, 0.5, 1]).
     * If hwb is an object it should contain key/value pairs for the three color components
     * (e.g., {h: 250, s: 0.5, v: 1]}). If hwb is a string, it should be a W3C CSS formatted
     * string (e.g., 'hwb(250, 0.5, 1)'. Note that hwb is not currently a W3C-accepted color
     * specification, but is provided for flexibility. Additionally, a fourth component component for the
     * alpha channel may be added. If hwb is an object the alpha component key should be *alpha*.
     * @returns {(Color | String)} If the hwb argument is not passed, A CSS hwb color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'hwb(250, 0.5, 1)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    HWB (hwb) {
        
        let rgb;

        if (hwb == undefined) {
            rgb = XYZtoRGB(this.#xyz, this.#colorSpace);
            return format('hwb', RGBtoHWB(rgb), this.#alpha);
        };

        const ranges = [{min:0,max:360},{min:0,max:1},{min:0,max:1},{min:0,max:1}];
        const keys = ['h', 'w', 'b'];

        const {components, alpha} = validate(hwb, keys, ranges, parseHwb);

        if (components != undefined) {
            rgb = HWBtoRGB (components);
            this.#xyz = RGBtoXYZ (rgb, this.#colorSpace);
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a CIE L\*a\*b value, or returns the  CIE L\*a\*b value of the current color.
     * @param {(Array | Object | String)} lab The lab argument should be either an
     * array, object, or string representing the lightness, red-green, and blue-yellow
     * components of the desired color. Valid values for these components are:
     * 
     * - l: 0 to 100%
     * - a: ±160
     * - b: ±160
     * 
     * If lab is an array, it should contain three elements (e.g., [0.6, -32, 64]). 
     * If lab is an object it should contain key/value pairs for the three color components
     * (e.g., {l: 0.6, a:-32, b: 64]}). If lab is a string, it should be a W3C CSS formatted
     * string (e.g., 'lab(60%, -32, 64)'. Additionally, a fourth component component for the
     * alpha channel may be added. If lab is an object the alpha component key should be *alpha*.
     * Valid values for the alpha component are [0..1].
     * @returns {(Color | String)} If the lab argument is not passed, A CSS lab color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'lab(60%, -32, 64)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    LAB (lab) {
        
        if (lab = undefined) return format('lab', XYZtoLAB(this.#xyz, this.#colorSpace, this.#observer), this.#alpha);
        
        const ranges = [{min:0,max:1},{min:-160,max:160},{min:-160,max:160},{min:0,max:1}];
        const keys = ['l', 'a', 'b'];

        const {components, alpha} = validate(lab, keys, ranges, parseLab);

        if (components != undefined) {
            this.#xyz = LABtoXYZ (components, this.#colorSpace, this.observer);
            if (alpha != undefined) this.#alpha = alpha; 
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a CIE L\*C\*h(a\*b\*) value, or returns the CIE L\*C\*h(a\*b\*) value of the current color.
     * CIE L\*C\*h(a\*b\*) is a cylindrical transformation of the CIE L\*\A\*B color space.
     * @param {(Array | Object | String)} lch The lch argument should be either an
     * array, object, or string representing the lightness, chroma, and hue
     * components of the desired color. Valid values for these components are:
     * 
     * - l: 0 to 100%
     * - c: 0 to 230
     * - h: 0 - 360 (degrees)
     * 
     * If lch is an array, it should contain three elements (e.g., [0.6, 210, 300]). 
     * If lch is an object it should contain key/value pairs for the three color components
     * (e.g., {l: 0.6, a:-32, b: 64]}). If lab is a string, it should be a W3C CSS formatted
     * string (e.g., 'lab(60%, 210, 300)'. Additionally, a fourth component component for the
     * alpha channel may be added. If lch is an object the alpha component key should be *alpha*.
     * Valid values for the alpha component are [0..1].
     * @returns {(Color | String)} If the lch argument is not passed, A CSS L\*C\*h color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'lch(60%, 210, 300)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    LCHab (lch) {

        let lab;

        if (lch == undefined) {
            lab =  XYZtoLAB (this.#xyz, this.#colorSpace, this.#observer);
            return format('lch', LABtoLCHab (lab), this.#alpha);
        };

        const ranges = [{min:0,max:1},{min:0,max:230},{min:0,max:360},{min:0,max:1}];
        const keys = ['l', 'c', 'h'];

        const {components, alpha} = validate(lch, keys, ranges, parseLch);

        if (components != undefined) {
            lab = LCHabToLAB (components);
            this.#xyz = LABtoXYZ (lab, this.#colorSpace, this.#observer);
            if (alpha != undefined) this.#alpha = alpha; 
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a CIE L\*u\*v value, or returns the CIE L\*u\*v value of the current color.
     * CIE L\*u\*v is a transformation of the CIE XYZ color space designed to
     * achieve perceptual uniformity.
     * @param {(Array | Object | String)} luv The luv argument should be either an
     * array, object, or string representing the lightness and the two chromacity
     * components of the desired color. Valid values for these components are:
     * 
     * - l: 0 to 100%
     * - u: ±100%
     * - v: ±100%
     * 
     * If luv is an array, it should contain three elements (e.g., [0.6, 0.1, -0.5]). 
     * If lch is an object it should contain key/value pairs for the three color components
     * (e.g., {l: 60%, u: 10%, v: -50%]}). If luv is a string, it should be a W3C CSS-formatted
     * string (e.g., 'luv(60%, 10%, -50%)'. Additionally, a fourth component component for the
     * alpha channel may be added. If luv is an object the alpha component key should be *alpha*.
     * Valid values for the alpha component are [0..1].
     * @returns {(Color | String)} If the luv argument is not passed, A CSS-style CIE L\*u\*v
     * color specification of the current [Color class object's]{@link Color} color value
     * (e.g., 'luv(60%, 10%, -50%)') is returned. *Note*: CIE does not currently support the
     * CIE L\*u\*v colorspace. Otherwise the [Color class object]{@link Color} is returned.
     */ 
    LUV (luv) {
        if (luv == undefined) return XYZtoLUV(this.#xyz, this.#colorSpace, this.#observer);

        const ranges = [{min:0,max:1},{min:0,max:1},{min:0,max:1},{min:0,max:1}];
        const keys = ['l', 'u', 'v'];

        const {components, alpha} = validate(luv, keys, ranges, parseLuv);

        if (components != undefined) {
            this.#xyz = LUVtoXYZ(luv, this.#colorSpace, this.#observer);
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;
    };


    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a CIE L\*C\*h(u\*v\*) value, or returns the CIE L\*C\*h(u\*v\*) value of the current color.
     * CIE L\*C\*h(u\*v\*) is a cylindrical transformation of the CIE L\*\u\*v color space.
     * @param {(Array | Object | String)} lch The lch argument should be either an
     * array, object, or string representing the lightness, chroma, and hue
     * components of the desired color. Valid values for these components are:
     * 
     * - l: 0 to 100%
     * - c: 0 to 230
     * - h: 0 - 360 (degrees)
     * 
     * If lch is an array, it should contain three elements (e.g., [0.6, 210, 300]). 
     * If lch is an object it should contain key/value pairs for the three color components
     * (e.g., {l: 0.6, a:-32, b: 64]}). If lab is a string, it should be a W3C CSS formatted
     * string (e.g., 'lab(60%, 210, 300)'. Additionally, a fourth component component for the
     * alpha channel may be added. If lch is an object the alpha component key should be *alpha*.
     * Valid values for the alpha component are [0..1].
     * @returns {(Color | String)} If the lch argument is not passed, A CSS L\*C\*h color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'lch(60%, 210, 300)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    LCHuv (lch) {
        
        let luv;
        
        if (lch == undefined) {
            luv = XYZtoLUV (this.#xyz, this.#colorSpace, this.#observer);
            return format('lch', LUVtoLCHuv (luv), this.#alpha);
        };

        const ranges = [{min:0,max:1},{min:0,max:230},{min:0,max:360},{min:0,max:1}];
        const keys = ['l', 'c', 'h'];

        const {components, alpha} = validate(lch, keys, ranges, parseLch);

        if (components != undefined) {
            luv = LCHuvToLUV (components);
            this.#xyz = LUVtoXYZ (luv, this.#colorSpace, this.#observer);
            if (alpha != undefined) this.#alpha = alpha; 
        };

        return this;    
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * an rgb value, or returns the rgb value of the current color.
     * @param {(Array | Object | String)} rgb The rgb argument should be either an
     * array, object, or string representing the red, green, and blue
     * components of the desired color. Valid values for these components are:
     * 
     * - r: 0 to 255
     * - g: 0 to 255
     * - b: 0 to 255
     * 
     * If rgb is an array, it should contain three elements (e.g., [255, 128, 0]).
     * If rgb is an object it should contain key/value pairs for the three color components
     * (e.g., {r: 255, g: 128, b: 0]}). If rgb is a string, it should be a W3C CSS formatted
     * string (e.g., 'rgb(255, 128, 0)'. Additionally, a fourth component component for the
     * alpha channel may be added. If rgb is an object the alpha component key should be *alpha*.
     * @returns {(Color | String)} If the rgb argument is not passed, A CSS rgb color specification
     * of the current [Color class object's]{@link Color} color value (e.g., 'rgb(255, 128, 0)')
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    RGB (rgb) {

        if (rgb == undefined) return  format('rgb', XYZtoRGB(this.#xyz, this.#colorSpace), this.#alpha);

        const ranges = [{min:0,max:255},{min:0,max:255},{min:0,max:255},{min:0,max:1}];
        const keys = ['r', 'g', 'b'];

        const {components, alpha} = validate(rgb, keys, ranges, parseRgb);

        if (components != undefined) {
            this.#xyz = RGBtoXYZ (components, this.#colorSpace);
            if (alpha != undefined) this.#alpha = alpha;
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * an integer value, or returns the integer value of the current color.
     * @param {Number} int The int argument should contain an integer [0..0xFFFFFF]
     * representing the desired color.
     * @returns {(Color | Number)} If the int argument is not passed, returns the
     * current [Color class object's]{@link Color} color value represented as an
     * integer. Otherwise the [Color class object]{@link Color} is returned.
     */
    RGBint (int) {

        if (int == undefined) return RGBtoINT(XYZtoRGB(this.#xyz, this.#colorSpace));

        if (validateRange(int, 0, 0xFFFFFF)) {
            const rgb = INTtoRGB(int);
            this.#xyz = RGBtoXYZ(rgb, this.#colorSpace);  
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * a W3C color, or returns the current color.
     * @param {String} w3cColor A valid W3C color string such as 'darkred'.
     * @returns {(Color | String)} If the w3cColor argument is not passed, returns the
     * current [Color class object's]{@link Color} color. Otherwise the 
     * [Color class object]{@link Color} is returned.
     */
    w3cColor (w3cColor) {
        
        if (w3cColor == undefined) return RGBtoW3C(XYZtoRGB(this.#xyz, this.#colorSpace));

        const rgb = W3CtoRGB (w3cColor);
        if (rgb == undefined) {
            console.error(`The input color, ${w3cColor} is not a valid CSS color.`);
        } else {
            this.#xyz = RGBtoXYZ ({rgb: r, rgb: g, rgb: b}, this.#colorSpace);
        };

        return this;
    }

    /**
     * Allows the stored color of the Color class object to be set by inputting
     * an xyz value, or returns the xyz value of the current color.
     * @param {(Array | Object)} xyz The xyz argument should be either an
     * array or an object representing the x, y, and z components of the desired color.
     * Valid values for these components are:
     * 
     * - x: 0 to 1
     * - y: 0 to 1
     * - z: 0 to 1
     * 
     * If xyz is an array, it should contain three elements (e.g., [0.5, 0.1, 0]).
     * If xyz is an object it should contain key/value pairs for the three color components
     * (e.g., {x: 0.5, y: 0.1, z: 0}).
     * @returns {(Color | Object)} If the xyz argument is not passed, The current
     * [Color class object's]{@link Color} color value (e.g.,  {x: 0.5, y: 0.1, z: 0})
     * is returned. Otherwise the [Color class object]{@link Color} is returned.
     */
    XYZ (xyz) {

        if (xyz == undefined) return this.#xyz;

        const ranges = [{min:0,max:1},{min:0,max:1},{min:0,max:1},{min:0,max:1}];
        const keys = ['x', 'y', 'z'];

        const {components, alpha} = validate(xyz, keys, ranges, undefined);

        if (components != undefined) {
            this.#xyz = components;
        };

        return this;
    }

    /**
     * Darkens the current [Color class object's]{@link Color} color by a given factor.
     * @param {(String | Number)} percent A string (e.g., 50%) or numerical
     * (e.g., 0.5) amount to darken by.
     * @returns {Color} The [Color class object]{@link Color}.
     */
    darken (percent) { 

        percent = parsePercent(percent);

        let hsl = RGBtoHSL(XYZtoRGB(this.#xyz, this.#colorSpace));
        const scaleFactor = Math.pow(0.7, percent);
        hsl.l = Math.max(0, hsl.l * scaleFactor);
        this.HSL(hsl.h, hsl.s, hsl.l);

        return this;
    }

    /**
     * Lightens the current [Color class object's]{@link Color} color by a given factor.
     * @param {(String | Number)} percent A string (e.g., 50%) or numerical
     * (e.g., 0.5) amount to lighten by.
     * @returns {Color} The [Color class object]{@link Color}.
     */
    lighten (percent) {
        
        percent = parsePercent(percent);

        let hsl = RGBtoHSL(XYZtoRGB(this.#xyz, this.#colorSpace));
        const scaleFactor = Math.pow((1 / 0.7), percent);
        hsl.l = Math.min(1, hsl.l * scaleFactor);
        this.HSL(hsl.h, hsl.l, hsl.s);

        return this;
    }

    /**
     * Saturates the current [Color class object's]{@link Color} color by a given factor.
     * @param {(String | Number)} percent A string (e.g., 50%) or numerical
     * (e.g., 0.5) amount to saturate by.
     * @returns {Color} The [Color class object]{@link Color}.
     */
    saturate (percent) {

        percent = parsePercent(percent);

        let hsl = RGBtoHSL(XYZtoRGB(this.#xyz, this.#colorSpace));
        const scaleFactor = Math.pow(0.7, percent);
        hsl.s = Math.min(1, hsl.s * scaleFactor);
        this.HSL(hsl.h, hsl.s, hsl.l);

        return this;
    }

    /**
     * Desaturates the current [Color class object's]{@link Color} color by a given factor.
     * @param {(String | Number)} percent A string (e.g., 50%) or numerical
     * (e.g., 0.5) amount to desaturate by.
     * @returns {Color} The [Color class object]{@link Color}.
     */
    desaturate (percent) {
        
        percent = parsePercent(percent);

        let hsl = RGBtoHSL(XYZtoRGB(this.#xyz, this.#colorSpace));
        const scaleFactor = Math.pow((1 / 0.7), percent);
        hsl.s = Math.max(0, hsl.s * scaleFactor);
        this.HSL(hsl.h, hsl.s, hsl.l);

        return this;
    }

    /**
     * Computes the text color (white or black) with the highest contrast with the
     * [Color class object's]{@link Color} color. See
     * [WCAG 2.0]{@link https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-procedure}.
     * @param {String} format The desired format to return the
     * [Color class object's]{@link Color} color. One of
     * ['cmyk' | 'hex' | 'hsl' | 'hsv' | 'hwb' | 'lab' | 'lch' | rgb' | 'int'].
     * **Default**: 'rgb'.
     * @returns {String} A W3C-formatted color specification of the requested forat
     * for either white or black.
     */
    contrastText(format = 'rgb') {

        let xyz;
        const rgbColor = XYZtoRGB(this.#xyz, this.#colorSpace);
        const l = RGBtoLuminance(rgbColor);

        const whiteContrast = 1.05 / (l  + 0.05);
        const blackContrast = (l  + 0.05) / 0.05;

        xyz = whiteContrast > blackContrast
            ? RGBtoXYZ({r: 255, g: 255, b: 255}, this.#colorSpace)
            : RGBtoXYZ({r: 0, g: 0, b: 0}, this.#colorSpace);

        return returnColor(xyz, this.#colorSpace, this.#observer, this.#alpha, format);

        // return this;
    }


}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Fri Nov 26 2021 10:26:20 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
