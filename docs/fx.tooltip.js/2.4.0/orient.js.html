<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>orient.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/MichaelRFox/fxToolTip.js" target="_blank" class="menu-item" id="source_link" >Source Code</a></h2><h3>Classes</h3><ul><li><a href="Tip.html">Tip</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Tip.html#content">content</a></li><li data-type='method' style='display: none;'><a href="Tip.html#orientation">orientation</a></li><li data-type='method' style='display: none;'><a href="Tip.html#preferredOrientation">preferredOrientation</a></li><li data-type='method' style='display: none;'><a href="Tip.html#autoPosition">autoPosition</a></li><li data-type='method' style='display: none;'><a href="Tip.html#autoSize">autoSize</a></li><li data-type='method' style='display: none;'><a href="Tip.html#mousePoint">mousePoint</a></li><li data-type='method' style='display: none;'><a href="Tip.html#trackMouse">trackMouse</a></li><li data-type='method' style='display: none;'><a href="Tip.html#cursor">cursor</a></li><li data-type='method' style='display: none;'><a href="Tip.html#font">font</a></li><li data-type='method' style='display: none;'><a href="Tip.html#foregroundColor">foregroundColor</a></li><li data-type='method' style='display: none;'><a href="Tip.html#backgroundColor">backgroundColor</a></li><li data-type='method' style='display: none;'><a href="Tip.html#backgroundOpacity">backgroundOpacity</a></li><li data-type='method' style='display: none;'><a href="Tip.html#padding">padding</a></li><li data-type='method' style='display: none;'><a href="Tip.html#borderRadius">borderRadius</a></li><li data-type='method' style='display: none;'><a href="Tip.html#boxShadow">boxShadow</a></li><li data-type='method' style='display: none;'><a href="Tip.html#transitionVisible">transitionVisible</a></li><li data-type='method' style='display: none;'><a href="Tip.html#transitionHidden">transitionHidden</a></li><li data-type='method' style='display: none;'><a href="Tip.html#arrowSize">arrowSize</a></li><li data-type='method' style='display: none;'><a href="Tip.html#width">width</a></li><li data-type='method' style='display: none;'><a href="Tip.html#maxWidth">maxWidth</a></li><li data-type='method' style='display: none;'><a href="Tip.html#minWidth">minWidth</a></li><li data-type='method' style='display: none;'><a href="Tip.html#height">height</a></li><li data-type='method' style='display: none;'><a href="Tip.html#maxHeight">maxHeight</a></li><li data-type='method' style='display: none;'><a href="Tip.html#minHeight">minHeight</a></li><li data-type='method' style='display: none;'><a href="Tip.html#remove">remove</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-fxTip.html">fxTip</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-fxTip.html#~create">create</a></li><li data-type='method' style='display: none;'><a href="module-fxTip.html#~remove">remove</a></li><li data-type='method' style='display: none;'><a href="module-fxTip.html#~checkDOM">checkDOM</a></li></ul></li><li><a href="module-index.html">index</a></li><li><a href="module-init.html">init</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-init.html#~setup">setup</a></li><li data-type='method' style='display: none;'><a href="module-init.html#~closeDown">closeDown</a></li></ul></li><li><a href="module-mouse.html">mouse</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-mouse.html#~getMouseCoordinates">getMouseCoordinates</a></li><li data-type='method' style='display: none;'><a href="module-mouse.html#~suspend">suspend</a></li></ul></li><li><a href="module-options.html">options</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-options.html#~applyOptions">applyOptions</a></li><li data-type='method' style='display: none;'><a href="module-options.html#~resetOptions">resetOptions</a></li></ul></li><li><a href="module-orient.html">orient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-orient.html#~position">position</a></li><li data-type='method' style='display: none;'><a href="module-orient.html#~optimumOrientation">optimumOrientation</a></li><li data-type='method' style='display: none;'><a href="module-orient.html#~getOrientation">getOrientation</a></li></ul></li><li><a href="module-style.html">style</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-style.html#~getRule">getRule</a></li><li data-type='method' style='display: none;'><a href="module-style.html#~getRuleIndex">getRuleIndex</a></li></ul></li><li><a href="module-tips.html">tips</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-tips.html#~getTipByElementId">getTipByElementId</a></li><li data-type='method' style='display: none;'><a href="module-tips.html#~sizeTip">sizeTip</a></li></ul></li><li><a href="module-utils.html">utils</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils.html#~getElementCoordinates">getElementCoordinates</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~overlap">overlap</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~hexToRgb">hexToRgb</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~createPseudoDiv">createPseudoDiv</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~parseColor">parseColor</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~parseSize">parseSize</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~checkSize">checkSize</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~checkBoolean">checkBoolean</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~checkFontFamily">checkFontFamily</a></li><li data-type='method' style='display: none;'><a href="module-utils.html#~checkCSS">checkCSS</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="module-fxTip.html#~event:detectTargetRemoval">detectTargetRemoval</a></li><li><a href="module-mouse.html#~event:mouseover">mouseover</a></li><li><a href="module-mouse.html#~event:mousemove">mousemove</a></li><li><a href="module-mouse.html#~event:mouseout">mouseout</a></li><li><a href="module-utils.html#~event:windowResized">windowResized</a></li></ul><h3>Global</h3><ul><li><a href="global.html#targetTimer">targetTimer</a></li><li><a href="global.html#sheet">sheet</a></li><li><a href="global.html#rules">rules</a></li><li><a href="global.html#ttDiv">ttDiv</a></li><li><a href="global.html#ttContainer">ttContainer</a></li><li><a href="global.html#beforeRule">beforeRule</a></li><li><a href="global.html#afterRule">afterRule</a></li><li><a href="global.html#targetRule">targetRule</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#mouseX">mouseX</a></li><li><a href="global.html#mouseY">mouseY</a></li><li><a href="global.html#tips">tips</a></li><li><a href="global.html#tipsIndex">tipsIndex</a></li><li><a href="global.html#windowWidth">windowWidth</a></li><li><a href="global.html#windowHeight">windowHeight</a></li><li><a href="global.html#aspectRatio">aspectRatio</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">orient.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** 
 * @module orient
 * @desc The orient module provides functions to determine the optimum orientation of a tooltip
 * if auto-sizing is set to true, and to set the proper CSS values for the tooltip's div elements. 
 */

import {ttDiv, beforeRule, afterRule} from './init.js';
import {windowHeight, windowWidth, getElementCoordinates, overlap, parseSize} from './utils.js';

/**
 * @function position
 * @desc Sets the position of the tooltip relative to the HTML element with which it is associated.
 * @param {string} targetElement The unique id of the HTML element that owns the tooltip.
 * @param {Tip} target The object containing all of the current tooltip's options and content.
 */
export function position (targetElement, target, orientation) {
    
    const targetCoordinates = getElementCoordinates(targetElement);
    const divWidth = ttDiv.getBoundingClientRect()['width'];
    const divHeight = ttDiv.getBoundingClientRect()['height'];
    const halfDivHeight = divHeight / 2;
    const halfDivWidth = divWidth / 2;
    const borderRadius = parseSize(target.borderRadius(), 'width', ttDiv);
    const arrowSize = parseSize(target.arrowSize(), 'width', ttDiv);

    afterRule.borderWidth = arrowSize + 'px';

    let top;
    let left;
    let verticalAdjust;
    let horizontalAdjust;
    let sizeAdjust;

    let adjustVertical = function (top) {
        let topAdjust = top;
        let arrowAdjust = halfDivHeight;

        if (top &lt; 0) { 
            topAdjust = 0;
            arrowAdjust = Math.max(arrowSize + borderRadius, top + halfDivHeight);
        } else if (top + divHeight > windowHeight) {
            topAdjust = windowHeight - divHeight;
            arrowAdjust = Math.min(divHeight - borderRadius - arrowSize, halfDivHeight +  top - topAdjust);
        };

        return {topAdjust: Math.round(topAdjust), arrowAdjust: Math.round(arrowAdjust)};
    }

    let adjustHorizontal = function (left) {
        let leftAdjust = left;
        let arrowAdjust = halfDivWidth;

        if (left &lt; 0) { 
            leftAdjust = 0;
            arrowAdjust = Math.max(arrowSize + borderRadius, left + halfDivWidth);
        } else if (left + divWidth > windowWidth) {
            leftAdjust = windowWidth - divWidth;
            arrowAdjust = Math.min(divWidth - borderRadius - arrowSize, halfDivWidth + left - leftAdjust);
        };

        return {leftAdjust: Math.round(leftAdjust), arrowAdjust: Math.round(arrowAdjust)};
    }

    switch (orientation) {
        case 'top': {
            top = targetCoordinates.top - arrowSize - divHeight;
            if (top &lt; 0) {
                beforeRule.height = Math.round(divHeight + top) + 'px';
                top = 0;
            };
            left = (targetCoordinates.width / 2) + targetCoordinates.left - halfDivWidth;
            horizontalAdjust = adjustHorizontal(left);

            beforeRule.top = Math.round(top) + 'px';
            beforeRule.left = horizontalAdjust.leftAdjust + 'px';

            afterRule.top = '99.5%';    //  '100%';
            afterRule.left = horizontalAdjust.arrowAdjust + 'px';
            afterRule.bottom = '';
            afterRule.right = '';   
            afterRule.marginLeft = -arrowSize + 'px';
            afterRule.marginTop = '';
            afterRule.borderColor = target.backgroundColor() + ' transparent transparent transparent';
            break;
        };
        case 'bottom': {
            top = targetCoordinates.top + targetCoordinates.height + arrowSize;
            sizeAdjust = windowHeight - divHeight + top + arrowSize;
            beforeRule.height = (sizeAdjust &lt; 0) ? (divHeight + sizeAdjust) + 'px' : beforeRule.height;
            left = (targetCoordinates.width / 2) + targetCoordinates.left - halfDivWidth;
            horizontalAdjust = adjustHorizontal(left);
            
            beforeRule.top = Math.round(top) + 'px'; 
            beforeRule.left = horizontalAdjust.leftAdjust + 'px'; 

            afterRule.top = '';
            afterRule.left = horizontalAdjust.arrowAdjust + 'px';
            afterRule.bottom = '99.5%'; //'100%';
            afterRule.right = '';
            afterRule.marginLeft = -arrowSize + 'px';
            afterRule.marginTop = '';
            afterRule.borderColor = 'transparent transparent ' + target.backgroundColor() + ' transparent';
            break;
        };
        case 'left': {
            top =  (targetCoordinates.height / 2) + targetCoordinates.top - halfDivHeight;
            left =  targetCoordinates.left - divWidth - arrowSize;
            if (left &lt; 0) {
                beforeRule.width = Math.round(divWidth + left) + 'px';
                left = 0;
            };
            verticalAdjust = adjustVertical(top);
            
            beforeRule.top = verticalAdjust.topAdjust + 'px';
            beforeRule.left = Math.round(left) + 'px';

            afterRule.top = verticalAdjust.arrowAdjust + 'px';
            afterRule.left = '99.5%';   //'100%';
            afterRule.bottom = '';
            afterRule.right = '';
            afterRule.marginLeft = '';
            afterRule.marginTop = -arrowSize + 'px';
            afterRule.borderColor = 'transparent transparent transparent ' + target.backgroundColor();
            break;
        };
        case 'right': {
            top = (targetCoordinates.height / 2) + targetCoordinates.top - halfDivHeight;
            left = targetCoordinates.left + targetCoordinates.width + arrowSize;
            sizeAdjust = windowWidth - divWidth + left + arrowSize;
            beforeRule.width = (sizeAdjust &lt; 0) ? (divWidth + sizeAdjust) + 'px' : beforeRule.width;
            verticalAdjust = adjustVertical(top);
            
            beforeRule.top = verticalAdjust.topAdjust + 'px'; 
            beforeRule.left = Math.round(left) + 'px';

            afterRule.top = verticalAdjust.arrowAdjust + 'px';
            afterRule.left = '';
            afterRule.bottom = '';
            afterRule.right = '99.5%';  //'100%';
            afterRule.marginLeft = '';
            afterRule.marginTop = -arrowSize + 'px';
            afterRule.borderColor = 'transparent ' + target.backgroundColor() + ' transparent transparent';
            break;
        };
    };
}

/**
 * @function optimumOrientation
 * @desc  Determines the best side upon which to place the tooltip.
 * If [auto-positioning]{@link Tip#autoPosition} is on, the
 * [preferred-orientation]{@link Tip#prefferedOrientation}
 * setting will be honored unless there is insufficient viewport space.
 * in this case, the position with the most available space will be used.
 * @param {string} targetElement The DOM element that is associated with the tooltip.
 * @param {Tip} target The [Tip]{@link Tip} class object containing all of the current tooltip's options and content.
 * @returns {string} One of ['left' | 'right' | 'top' | 'bottom'].
 * @since v2.2.0
 */

export function optimumOrientation (targetElement, target) {

    const elementCoordinates = getElementCoordinates(targetElement);
    const arrowSize = parseSize(target.arrowSize(), 'width', ttDiv);

    const midX = elementCoordinates.left + (elementCoordinates.width / 2);
    const midY = elementCoordinates.top + (elementCoordinates.height / 2);

    const divWidth = ttDiv.getBoundingClientRect()['width'];
    const divHeight = ttDiv.getBoundingClientRect()['height'];
    const halfDivHeight = divHeight / 2;
    const halfDivWidth = divWidth / 2;

    const leftOverlap = overlap ('left',
        {
            x0: elementCoordinates.left - arrowSize - divWidth,
            x1: elementCoordinates.left - arrowSize,
            y0: midY - halfDivHeight,
            y1: midY + halfDivHeight
        });
    const rightOverlap = overlap ('right',
        {
            x0: elementCoordinates.left + elementCoordinates.width + arrowSize,
            x1: elementCoordinates.left + elementCoordinates.width + arrowSize + divWidth, 
            y0: midY - halfDivHeight,
            y1: midY + halfDivHeight
        });
    const topOverlap = overlap ('top',
        {
            x0: midX - halfDivWidth,
            x1: midX + halfDivWidth,
            y0: elementCoordinates.top - arrowSize - divHeight, 
            y1: elementCoordinates.top - arrowSize
        });
    const bottomOverlap = overlap ('bottom',
        {
            x0: midX - halfDivWidth,
            x1: midX + halfDivWidth,
            y0: elementCoordinates.top + elementCoordinates.height + arrowSize,
            y1: elementCoordinates.top + elementCoordinates.height + arrowSize + divHeight
        });

    switch (target.preferredOrientation()) {
        case 'left': { if (leftOverlap.overlap == 1) return 'left'; break; };
        case 'right': { if (rightOverlap.overlap == 1) return 'right'; break; };
        case 'top': { if (topOverlap.overlap == 1) return 'top'; break; };
        case 'bottom': { if (bottomOverlap.overlap == 1) return 'bottom'; break; };
    };

    // if there is no preferred orientation or all overlaps are less than 1
    let overlaps = [leftOverlap, rightOverlap, topOverlap, bottomOverlap];

    //if all of the overlaps are less than 1 return the greatest
    if (leftOverlap.overlap &lt; 1 &amp;&amp; rightOverlap.overlap &lt; 1 &amp;&amp; topOverlap.overlap &lt; 1 &amp;&amp; bottomOverlap.overlap &lt; 1) {
        return overlaps[overlaps.reduce((prev, current, index, array) => {
            if (current.overlap > array[prev].overlap) {return index} else {return prev};
        }, 0)].side;
    };

    // remove all overlaps that are less than 1
    overlaps = overlaps.reduce((prev, current) => {
        if (current.overlap == 1) {return prev.concat(current)} else {return prev};
    }, []);

    if (overlaps.length == 1) { return overlaps[0].side; }; // only one left;

    return overlaps[overlaps.reduce((prev, current, index, array) => {
        if (current.spacing[current.side] >= array[prev].spacing[prev.side]) {return index} else { return prev} ;
    }, 0)].side;
}

/**
 * @function getOrientation
 * @desc Selects the appropriate orientation by deconflicting [auto-positioning]{@link Tip#autoPosition},
 * [prefererd-orientation]{@link Tip#preferredOrientation, and [orientation]{@link Tip#orientation}
 * settings in the Tip{} class object.
 * @param {string} targetElement The DOM element that is associated with the tooltip.
 * @param {Tip} target The [Tip]{@link Tip} class object containing all of the current tooltip's options and content.
 * @returns {string} One of ['left' | 'right' | 'top' | 'bottom'].
 * @since v2.1.2
 */
export function getOrientation (targetElement, target) {
    if (target.orientation() != undefined) return target.orientation();
    if (target.autoPosition()) return optimumOrientation (targetElement, target);
    if (target.preferredOrientation() != 'none') return target.preferredOrientation();
    return 'right';
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a> on Thu Feb 03 2022 14:54:12 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
